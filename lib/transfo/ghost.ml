open Prelude
open Resource_formula
open Resource_contract
open Resources

let rec contains_only_ghost_code (t: trm): bool =
  match t.desc with
  | Trm_apps _ when trm_has_attribute GhostInstr t -> true
  | Trm_seq (seq, None) -> List.for_all contains_only_ghost_code (Mlist.to_list seq)
  | Trm_for (_, _, body, _) -> contains_only_ghost_code body
  | _ -> false

let embed_loop_on (mark : mark) (t: trm): trm =
  let res = Resources.before_trm t in
  let t = loop_minimize_on t in
  if not (contains_only_ghost_code t) then failwith "Ghost.embed_loop_on: the loop contains non ghost code";
  let range, mode, body, contract = trm_inv ~error:"Ghost.embed_loop_on: can only be applied on a for loop" trm_for_inv t in
  match mode with
  | Sequential | Parallel ->
    let _, outer_contract = get_loop_contract_generators res mode range contract in
    trm_add_mark mark (Resource_trm.ghost (ghost_closure_call (outer_contract ()) (trm_seq (Mlist.of_list [trm_copy t]))))
  | _ -> failwith "Ghost.embed_loop_on: loop mode %s is unsupported" (show_loop_mode mode)


let%transfo embed_loop ?(mark : mark = "") (tg: target): unit =
  Resources.ensure_computed ();
  Target.apply_at_target_paths (embed_loop_on mark) tg;
  Resources.justif_correct "only changed ghost code"

(** <private> *)
let farthest_commuting_pos (i : int) (direction : int) (seq : trm) : int =
  let error = "Ghost_pair.move_in_seq: expected sequence" in
  let instrs, _ = trm_inv ~error trm_seq_inv seq in
  let instr = Mlist.nth instrs i in
  let current_i = ref i in
  let dest_offset, interference_with_instr =
    match direction with
    | -1 -> 0, fun next -> collect_trm_interferences next instr
    | 1 -> 1, fun next -> collect_trm_interferences instr next
    | _ -> failwith "Ghost.farthest_commuting_pos: expected -1 or 1 direction"
  in
  let commutes_with_next () : bool =
    let next_i = !current_i + direction in
    let commutes = match Mlist.nth_opt instrs next_i with
    | Some next ->
      let interference = interference_with_instr next in
      let commutes = Var_map.is_empty interference in
      (* DEBUG:
      if not commutes then
        print_string (string_of_interference interference); *)
      commutes
    | None ->
      false
    in
    if commutes then current_i := next_i;
    commutes
  in
  while commutes_with_next () do () done;
  !current_i + dest_offset

(** Moves instruction at index [i] in sequence [seq] as far down as possible, as long as effects commute. *)
let move_down_in_seq (i : int) (seq : trm) : trm =
  let desired_pos = farthest_commuting_pos i 1 seq in
  if desired_pos <= i + 1 then
    seq
  else
    Instr_core.move_at desired_pos i seq

(** Moves instruction at index [i] in sequence [seq] as far up as possible, as long as effects commute. *)
let move_up_in_seq (i : int) (seq : trm) : trm =
  let desired_pos = farthest_commuting_pos i (-1) seq in
  if desired_pos >= i then
    seq
  else
    Instr_core.move_at desired_pos i seq

(** Replace the ghost binding for [contract_var] by [new_binding] in [ghost_bind],
    adding it if it does not exist. *)
let replace_in_ghost_bind ghost_bind contract_var new_binding =
  let found, ghost_bind = List.fold_left_map (fun found cur_bind ->
      if var_eq contract_var (snd cur_bind) then true, (None, contract_var) else found, cur_bind
    ) false ghost_bind
  in
  if found then ghost_bind else (None, contract_var) :: ghost_bind

exception NotBound

(** Replace the binding of [old_bound_var] to [new_binding] for the function call [call].
    [old_bound_var] can be an autogenerated binding name.
    If [old_bound_var] is not bound by [call], raise the exception [NotBound] *)
let rename_ghost_bind call old_bound_var new_binding =
  Pattern.pattern_match call [
    Pattern.(trm_apps !__ !__ !__ !__) (fun fn args ghost_args ghost_bind () ->
      let found, ghost_bind = List.fold_left_map (fun found cur_bind ->
          match cur_bind with
          | Some cur_bound_var, contract_var when var_eq cur_bound_var old_bound_var ->
            true, (new_binding, contract_var)
          | _ -> found, cur_bind
        ) false ghost_bind
      in
      let ghost_bind = if found then ghost_bind else
        match call.ctx.ctx_resources_contract_invoc with
        | Some invoc ->
          let hyp_names = invoc.contract_produced.contract_hyp_names in
          begin match Var_map.find_opt old_bound_var hyp_names with
          | Some contract_hyp -> (new_binding, contract_hyp) :: ghost_bind
          | None -> raise NotBound
          end
        | None -> trm_fail call "Contract invocation not computed for trm_apps"
      in
      trm_replace (trm_apps fn args ~ghost_args ~ghost_bind).desc call
    );
    Pattern.__ (fun () -> raise NotBound)
  ]
